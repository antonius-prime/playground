package hr.fer.zemris.bool.qmc;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import hr.fer.zemris.bool.BooleanFunction;
import hr.fer.zemris.bool.Mask;
import hr.fer.zemris.bool.fimpl.MaskBasedBF;
import hr.fer.zemris.bool.qmc.symbolic.Symbol;
import hr.fer.zemris.bool.qmc.symbolic.SymbolicConjunction;
import hr.fer.zemris.bool.qmc.symbolic.SymbolicDisjunction;
import hr.fer.zemris.bool.qmc.symbolic.SymbolicExpression;

/**
 * Class used for minimization of boolean functions which are defined by {@link BooleanFunction}
 * interface. Minimization algorithm being used is the Quine-McCluskey algorithm. Minimization
 * itself results with an array of {@link MaskBasedBF} instances. That array is disjunct set
 * conjunctions of given function domains variables.
 * 
 * @author Antonio Paunovic
 * @version 0.1
 * @see <a href="http://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm">Quine-McCluskey
 *      algorithm</a>
 */
public class QMCMinimizer {

  private QMCMinimizer() {}

  /**
   * This method minimizes the given function using the Quine-McCluskey algorithm.
   * 
   * @param bf boolean function to minimize.
   * @return array of {@link MaskBasedBF} instances where each instance represents a minterm of the
   *         minimized function.
   */
  public static MaskBasedBF[] minimize(BooleanFunction bf) {
    // From table extract minterm and dontcare rows.
    // Transform rows to masks.
    // Create table partitioned by the number of ones (these can be combined among themselves).
    Map<Integer, Set<Implicant>> partitionTable = createPartitionTable(bf);
    // Combine combinable masks until none resulting masks can combine.
    // Construct essential prime implicant table.

    Set<Implicant> implicants = partitionToImplicantTable(partitionTable);
    int index = 0;
    for (Implicant implicant : implicants) {
      implicant.setAlias("P" + index);
      index++;
    }

    Map<Integer, ArrayList<String>> mintermSymbols = new HashMap<>();
    for (Integer minterm : bf.mintermIterable()) {
      mintermSymbols.put(minterm, new ArrayList<String>());
    }

    // Do the Pyne-McCluskey minimization.
    List<MaskBasedBF> maskFunctions = new ArrayList<>();
    for (SymbolicExpression expr : pyne(implicants, mintermSymbols)) {
      List<Mask> masksForFunction = new ArrayList<>();

      // Get masks for resulting minimization.
      for (SymbolicExpression symbol : expr.getOperands()) {
        masksForFunction.add(Implicant.getMaskByAlias(implicants, symbol.toString()));
      }

      // Generate functions.
      MaskBasedBF func =
          new MaskBasedBF("f" + maskFunctions.size(), bf.getDomain(), true, masksForFunction,
              new ArrayList<Mask>());
      maskFunctions.add(func);
    }

    return (MaskBasedBF[]) maskFunctions.toArray(new MaskBasedBF[maskFunctions.size()]);
  }

  /**
   * For a given {@link BooleanFunction}, this method creates a partitioning table. It is called
   * partitioning table because the entries are partitioned by some parameter. In this case that
   * parameter is the number of ones in the mask generated by turning indices of minterms and don't
   * cares to the masks.
   * 
   * @param bf function for which the table is created.
   * @return map of integers which represent number of ones in the masks stored in the corresponding
   *         implicants.
   */
  private static Map<Integer, Set<Implicant>> createPartitionTable(BooleanFunction bf) {
    final int domainSize = bf.getDomain().size();
    Map<Integer, Set<Implicant>> partitionTable = new HashMap<>(domainSize);

    createPartitionTableHelper(bf.mintermIterable(), partitionTable, domainSize);
    createPartitionTableHelper(bf.dontcareIterable(), partitionTable, domainSize);

    return partitionTable;
  }

  /**
   * Helper method which does the work for createPartitionTable method
   * 
   * @param indices {@link Iterable}, indices of minterms, dontcares, maxterms...
   * @param partitionTable existing partition table to build upon.
   * @param domainSize size of the domain, used for mask creation.
   */
  private static void createPartitionTableHelper(Iterable<Integer> indices,
      Map<Integer, Set<Implicant>> partitionTable, int domainSize) {

    for (Integer index : indices) {
      final Mask row = Mask.fromIndex(domainSize, index);
      final Integer oneCount = row.getNumberOfOnes();

      if (partitionTable.containsKey(oneCount)) {
        partitionTable.get(oneCount).add(new Implicant(Collections.singleton(index), row));
      } else {
        Set<Implicant> entry = new HashSet<Implicant>();
        entry.add(new Implicant(Collections.singleton(index), row));
        partitionTable.put(oneCount, entry);
      }
    }
  }

  /**
   * Using a given generated partitionTable, create a implicant table. Implicant table is table in
   * which minterms from partitioning table different groups are combined (no minterms in same group
   * can be combined). Their {@link Mask} instances are combined and a set of minterms which were
   * used in some combination are also stored in {@link Implicant} class instance. At the end, table
   * is consisting of implicants which can't combine any more. Remaining implicants are prime
   * implicants.
   * 
   * @param partitionTable partition table of minterms (and don't cares).
   * @return Set of implicants.
   */
  private static Set<Implicant> partitionToImplicantTable(
      Map<Integer, Set<Implicant>> partitionTable) {
    Set<Implicant> startImplicants = new HashSet<>();
    for (Integer oneCount : partitionTable.keySet()) {
      startImplicants.addAll(initImplicantTable(oneCount, partitionTable));
    }

    return toImplicantsStep(startImplicants);
  }

  /**
   * First step of creating implicant table. Given group is combined with remaining groups.
   * 
   * @param group group in partition table.
   * @param partitionTable
   * @return set of implicants resulting from combinations.
   */
  private static Set<Implicant> initImplicantTable(Integer group,
      Map<Integer, Set<Implicant>> partitionTable) {

    Set<Implicant> combinations = new HashSet<>();

    for (Implicant groundImplicant : partitionTable.get(group)) {

      for (Entry<Integer, Set<Implicant>> entry : partitionTable.entrySet()) {
     
        Integer otherGroup = entry.getKey();
        Set<Implicant> implicants = entry.getValue();
        
        if (group < otherGroup) {
        
          for (Implicant otherImplicant : implicants) {
            Mask maskCombo = Mask.combine(groundImplicant.getMask(), otherImplicant.getMask());
          
            if (maskCombo != null) {
              Set<Integer> mintermsCombo = new HashSet<>();
              mintermsCombo.addAll(groundImplicant.getMinterms());
              mintermsCombo.addAll(otherImplicant.getMinterms());
              Implicant combined = new Implicant(mintermsCombo, maskCombo);
              combinations.add(combined);
            }
          }
        }
      }
    }

    return combinations;
  }

  /**
   * General step in creating implicants table. When some implicant can't combine any more, it is
   * added to the resulting set. This step is repeated recursively until all of the implicants which
   * could get combined, got combined.
   * 
   * @param implicants set of implicants to combine.
   * @return set of implicants which can't combine any more.
   */
  private static Set<Implicant> toImplicantsStep(Set<Implicant> implicants) {
    Set<Implicant> combinations = new HashSet<>();
    Set<Implicant> cantCombine = new HashSet<>();

    // End of recursion. No more implicants to combine.
    if (implicants.isEmpty())
      return Collections.emptySet();

    // Combine all implicants.
    for (Implicant thisImplicant : implicants) {
      boolean canCombine = false;

      for (Implicant otherImplicant : implicants) {

        if (thisImplicant != otherImplicant) {
          Mask maskCombo = Mask.combine(thisImplicant.getMask(), otherImplicant.getMask());
          if (maskCombo != null) {
            canCombine = true;
            Set<Integer> mintermsCombo = new HashSet<>();
            mintermsCombo.addAll(thisImplicant.getMinterms());
            mintermsCombo.addAll(otherImplicant.getMinterms());
            Implicant combined = new Implicant(mintermsCombo, maskCombo);
            combinations.add(combined);
          }
        }
      }

      // Add those who won't combine to the resulting set.
      if (!canCombine) {
        cantCombine.add(thisImplicant);
      }

    }

    // Recursive step.
    cantCombine.addAll(toImplicantsStep(combinations));

    return cantCombine;
  }

  /**
   * Method which implements Pyne-McCluskey algorithm used for attaining the minimal forms of the
   * prime implicants.
   * 
   * @param implicants prime implicants for which the minimization is done, both minterm and don't
   *        care implicants are included.
   * @param mintermSymbols map of minterms and empty lists. Each empty list will be filled with
   *        aliases of implicants for which minterm is defined.
   * @return list of minimized formula containing only formulas which are constituted from least
   *         literals.
   * @see <a="http://en.wikipedia.org/wiki/Petrick%27s_method">Algorithm article.</a>
   */
  private static List<SymbolicExpression> pyne(Set<Implicant> implicants,
      Map<Integer, ArrayList<String>> mintermSymbols) {

    // List of aliases of implicants for which minterm is defined.
    for (Implicant implicant : implicants) {
      for (Integer minterm : implicant.getMinterms()) {
        if (mintermSymbols.containsKey(minterm)) {
          mintermSymbols.get(minterm).add(implicant.getAlias());
        }
      }
    }

    // Construct formula from aliases defined for each minterm.
    List<SymbolicExpression> conjOperands = new ArrayList<>();
    for (Entry<Integer, ArrayList<String>> entry : mintermSymbols.entrySet()) {
      List<SymbolicExpression> disjOperands = new ArrayList<>();

      for (String symb : entry.getValue()) {
        disjOperands.add(new Symbol(symb));
      }
      conjOperands.add(new SymbolicDisjunction(disjOperands));
    }
    SymbolicExpression pyneFormula = new SymbolicConjunction(conjOperands);

    return fewestLiterals(pyneFormula.evaluate());
  }

  /**
   * Used in Pyne-McCluskey algorithm. For operands in some formula, return list of those who got
   * fewest themselves.
   * 
   * @param formula for wich operands with fewest literals are extracted.
   * @return list of operands with fewest operands.
   */
  private static List<SymbolicExpression> fewestLiterals(SymbolicExpression formula) {
    int min = Integer.MAX_VALUE;
    List<SymbolicExpression> minSyms = new ArrayList<>();

    for (SymbolicExpression expr : formula.getOperands()) {
      int literalCount = expr.getOperands().size();
      if (literalCount < min) {
        min = literalCount;
        minSyms = new ArrayList<>();
        minSyms.add(expr);
      } else if (literalCount == min) {
        minSyms.add(expr);
      }
    }

    return minSyms;
  }
}
